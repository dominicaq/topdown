#pragma kernel CSMain
#pragma kernel UpscaleFogTex
#pragma kernel HorizontalBlur
#pragma kernel VerticalBlur
#pragma kernel LerpPass

// Fog textures and buffers
RWTexture2D<float4> FogTex;
RWTexture2D<float4> PrevFogTex;
StructuredBuffer<uint> LightMap;

// Upscaling
Texture2D<float4> InputTex;
RWTexture2D<float4> OutputTex;

// Blur
RWTexture2D<float4> BlurTemp;

// Parameters
uint _chunkSize;
uint _tileSize;
uint _upscaleSize;
float _scaleFactor;
float _blurStrength;
float _lerpSpeed;
float _deltaTime;

[numthreads(8, 8, 1)]
void CSMain(uint2 id : SV_DispatchThreadID)
{
    uint tileX = id.x * 4;
    uint tileY = id.y;

    if (tileX >= _chunkSize || tileY >= _chunkSize)
        return;

    int packedIndex = tileY * (_chunkSize >> 2) + id.x;
    uint packedTiles = LightMap[packedIndex];

    [unroll]
    for (uint i = 0; i < 4; i++) {
        uint shift = i * 8;
        uint tileByte = (packedTiles >> shift) & 0xFF;

        float alpha = (tileByte >> 7) ? 0.0 : ((tileByte >> 6) & 1) ? 0.7 : 1.0;

        uint2 pixelPos = uint2(tileX + i, tileY);
        FogTex[pixelPos] = float4(0, 0, 0, alpha);
    }
}

[numthreads(16, 16, 1)]
void UpscaleFogTex(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize || id.y >= _upscaleSize)
        return;

    uint2 sourcePos = uint2(id.x / _scaleFactor, id.y / _scaleFactor);
    float4 color = InputTex[sourcePos];

    OutputTex[id] = color;
}

[numthreads(256, 1, 1)]
void HorizontalBlur(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize || id.y >= _upscaleSize)
        return;

    float weights[3] = { 0.4026, 0.2442, 0.0545 };
    float4 color = OutputTex[uint2(id.x, id.y)] * weights[0];

    [unroll]
    for (int i = 1; i < _blurStrength; i++) {
        uint x1 = min(id.x + i, _upscaleSize - 1);
        uint x2 = max(int(id.x) - i, 0);

        color += OutputTex[uint2(x1, id.y)] * weights[i];
        color += OutputTex[uint2(x2, id.y)] * weights[i];
    }

    BlurTemp[id.xy] = color;
}

[numthreads(1, 256, 1)]
void VerticalBlur(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize || id.y >= _upscaleSize)
        return;

    float weights[3] = { 0.4026, 0.2442, 0.0545 };
    float4 color = BlurTemp[uint2(id.x, id.y)] * weights[0];

    [unroll]
    for (int i = 1; i < _blurStrength; i++) {
        uint y1 = min(id.y + i, _upscaleSize - 1);
        uint y2 = max(int(id.y) - i, 0);

        color += BlurTemp[uint2(id.x, y1)] * weights[i];
        color += BlurTemp[uint2(id.x, y2)] * weights[i];
    }

    OutputTex[id.xy] = color;
}

[numthreads(8, 8, 1)]
void LerpPass(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize || id.y >= _upscaleSize)
        return;

    float4 fogCurrent = FogTex[id.xy];
    float4 fogPrevious = PrevFogTex[id.xy];

    float lerpFactor = saturate(_lerpSpeed * _deltaTime * 15.0);
    float quickFade = pow(lerpFactor, 0.3);

    // Only force opacity when the target state is fully opaque
    if (fogCurrent.a >= 0.99)
    {
        // Accelerate the transition to full opacity
        float adjustedLerp = pow(quickFade, 0.5); // Makes transition to black faster
        FogTex[id.xy] = lerp(fogPrevious, float4(0,0,0,1), adjustedLerp);
    }
    else
    {
        // Normal lerp for all other cases
        FogTex[id.xy] = lerp(fogPrevious, fogCurrent, quickFade);
    }
}