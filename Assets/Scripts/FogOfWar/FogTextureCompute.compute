#pragma kernel CSMain
#pragma kernel UpscaleFog
#pragma kernel HorizontalBlur
#pragma kernel VerticalBlur

// Textures and buffers
RWTexture2D<float4> FogTex;
StructuredBuffer<uint> LightMap;
Texture2D<float4> InputTex;
RWTexture2D<float4> OutputTex;
RWTexture2D<float4> BlurTemp;

// Parameters
int _chunkSize;
uint2 _upscaleSize;
float2 _scaleFactor;
float _blurStrength;

// Optimized CSMain with larger thread groups
[numthreads(8, 8, 1)]
void CSMain(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= (uint)_chunkSize || id.y >= (uint)_chunkSize)
        return;

    // Process 4 tiles at once using bit operations
    uint tileX = id.x;
    uint tileY = id.y;
    int packedIndex = (tileY * _chunkSize + tileX) >> 2;
    uint shift = (tileX & 3) << 3;
    uint tileByte = (LightMap[packedIndex] >> shift) & 0xFF;

    // Fast branching using bit operations
    float alpha = (tileByte >> 7) ? 0.0 : ((tileByte >> 6) & 1) ? 0.7 : 1.0;
    FogTex[id] = float4(0, 0, 0, alpha);
}

// Fast nearest-neighbor upscale with minimal texture fetches
[numthreads(16, 16, 1)]
void UpscaleFog(uint2 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize.x || id.y >= _upscaleSize.y)
        return;

    // Simple and fast upscale calculation
    uint2 sourcePos = uint2(id.x / _scaleFactor.x, id.y / _scaleFactor.y);
    float4 color = InputTex[sourcePos];

    OutputTex[id] = color;
}

// Separable Gaussian blur - horizontal pass
[numthreads(256, 1, 1)]
void HorizontalBlur(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize.x || id.y >= _upscaleSize.y)
        return;

    // Fast 5-tap blur
    float weights[3] = { 0.4026, 0.2442, 0.0545 };

    float4 color = OutputTex[uint2(id.x, id.y)] * weights[0];

    [unroll]
    for (int i = 1; i < 3; i++)
    {
        uint x1 = min(id.x + i, _upscaleSize.x - 1);
        uint x2 = max(int(id.x) - i, 0);

        color += OutputTex[uint2(x1, id.y)] * weights[i];
        color += OutputTex[uint2(x2, id.y)] * weights[i];
    }

    BlurTemp[id.xy] = color;
}

// Separable Gaussian blur - vertical pass
[numthreads(1, 256, 1)]
void VerticalBlur(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _upscaleSize.x || id.y >= _upscaleSize.y)
        return;

    // Fast 5-tap blur
    float weights[3] = { 0.4026, 0.2442, 0.0545 };

    float4 color = BlurTemp[uint2(id.x, id.y)] * weights[0];

    [unroll]
    for (int i = 1; i < 3; i++)
    {
        uint y1 = min(id.y + i, _upscaleSize.y - 1);
        uint y2 = max(int(id.y) - i, 0);

        color += BlurTemp[uint2(id.x, y1)] * weights[i];
        color += BlurTemp[uint2(id.x, y2)] * weights[i];
    }

    OutputTex[id.xy] = color;
}
